import os
import textwrap
from typing import List

from dotenv import load_dotenv
from openai import OpenAI
from pydantic import BaseModel, Field, field_validator, model_validator

# .env dosyasÄ±ndan API anahtarÄ±nÄ± yÃ¼kle
load_dotenv()

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# --- 1. Validasyon KatmanÄ± (GEO KurallarÄ±) ---
# GEO belgesindeki 40-80 kelime ve zamir kuralÄ±nÄ± burada kodla denetliyoruz.

_INTENT_CHOICES = {
    "TanÄ±m",
    "KarÅŸÄ±laÅŸtÄ±rma",
    "KÄ±sÄ±tlar",
    "NasÄ±l YapÄ±lÄ±r",
}


class AnswerBlock(BaseModel):
    intent_category: str = Field(
        ...,
        description="Sorgunun niyeti: 'TanÄ±m', 'KarÅŸÄ±laÅŸtÄ±rma', 'KÄ±sÄ±tlar' veya 'NasÄ±l YapÄ±lÄ±r'",
    )
    target_query: str = Field(..., description="KullanÄ±cÄ±nÄ±n muhtemel fan-out sorgusu (Ã–rn: 'Jotform vs Zapier fiyat')")
    heading: str = Field(..., description="Blog yazÄ±sÄ±nda H2 veya H3 olarak kullanÄ±lacak baÅŸlÄ±k")
    content: str = Field(..., description="DoÄŸrudan cevabÄ± iÃ§eren snippet metni")
    relevance_score: int = Field(..., description="LMP Relevance PuanÄ± (0-100). Ä°Ã§erik soruyla ne kadar alakalÄ±?")

    @field_validator("intent_category")
    def validate_intent(cls, value: str) -> str:
        if value not in _INTENT_CHOICES:
            raise ValueError(f"intent_category '{value}' desteklenmiyor. GeÃ§erli seÃ§enekler: {_INTENT_CHOICES}")
        return value

    @field_validator("content")
    def validate_geo_rules(cls, value: str) -> str:
        # Kural 1: Kelime SayÄ±sÄ± (GEO Taktikleri: 40-80 kelime ideal snippet)
        word_count = len(value.split())
        if word_count < 40 or word_count > 80:
            raise ValueError(
                f"Answer Block uzunluÄŸu GEO standartlarÄ±na uymuyor ({word_count} kelime). 40-80 arasÄ± olmalÄ±."
            )

        # Kural 2: Zamir BelirsizliÄŸi (GEO Taktikleri: 'Bu', 'O' gibi belirsiz giriÅŸler yasak)
        forbidden_starts = ["bu ", "o ", "ÅŸu ", "bunlar ", "it ", "this ", "they "]
        if any(value.lower().startswith(start) for start in forbidden_starts):
            raise ValueError("Metin belirsiz bir zamirle baÅŸlÄ±yor. LÃ¼tfen Ã¶zneyi (Brand Name/Product) aÃ§Ä±kÃ§a yaz.")

        return value

    @field_validator("heading")
    def heading_cannot_be_blank(cls, value: str) -> str:
        if not value.strip():
            raise ValueError("heading boÅŸ olamaz")
        return value.strip()

    @field_validator("relevance_score")
    def score_range(cls, value: int) -> int:
        if not 0 <= value <= 100:
            raise ValueError("relevance_score 0-100 arasÄ±nda olmalÄ±")
        return value


class FanOutResult(BaseModel):
    main_keyword: str
    analysis_summary: str = Field(..., description="Neden bu fan-out sorgularÄ±nÄ±n seÃ§ildiÄŸine dair kÄ±sa stratejik Ã¶zet.")
    blocks: List[AnswerBlock]

    @model_validator(mode="after")
    def validate_blocks(self) -> "FanOutResult":
        block_count = len(self.blocks)
        if not 3 <= block_count <= 5:
            raise ValueError(f"3-5 arasÄ±nda Answer Block bekleniyordu, {block_count} geldi")

        queries = [block.target_query.lower() for block in self.blocks]
        if len(queries) != len(set(queries)):
            raise ValueError("target_query deÄŸerleri benzersiz olmalÄ±")

        return self


# --- 2. AI Motoru (The Architect) ---

def _build_system_prompt() -> str:
    return textwrap.dedent(
        """
        Sen Ã¼st dÃ¼zey bir GEO (Generative Engine Optimization) uzmanÄ±sÄ±n.
        GÃ¶revin: Verilen blog iÃ§eriÄŸini analiz etmek ve 'Fan-Out' (YayÄ±lÄ±m) sorgularÄ±nÄ± tespit etmektir.

        GEO KURALLARI:
        1. AI modelleri (ChatGPT, Google AI) sadece 'Answer Block'larÄ± okur.
        2. Her blok kendi baÅŸÄ±na ayakta durabilmelidir (Standalone).
        3. Asla 'GiriÅŸ' veya 'SonuÃ§' cÃ¼mlesi yazma. DoÄŸrudan cevabÄ± ver.
        4. SayÄ±sal veriler (Fiyat, Limit, YÃ¼zde) varsa mutlaka kullan.
        5. 'Because / Therefore' mantÄ±ksal yapÄ±sÄ±nÄ± kullanmaya Ã§alÄ±ÅŸ.

        LMP (Language Model Pipeline) SÄ°MÃœLASYONU:
        - ÃœrettiÄŸin her bloÄŸu 0-100 arasÄ±nda puanla. EÄŸer metin soruyu tam karÅŸÄ±lamÄ±yorsa puanÄ± dÃ¼ÅŸÃ¼r.

        FAN-OUT ARAÅTIRMA PRENSÄ°PLERÄ°:
        - Fan-out sorgularÄ± aynÄ± SERP niyeti altÄ±nda kÃ¼melensin; tekrarlayan entegrasyon/Ã¶zellik vurgularÄ±ndan kaÃ§Ä±n.
        - Arama hacmi yÃ¼ksek varyasyonlarÄ± ("fiyat", "entegrasyon", "gÃ¼venlik", "alternatifler") iÃ§ermeye Ã¶ncelik ver.
        - Her blok tek bir problem veya karar anÄ±na cevap vermeli.
        """
    ).strip()


def _build_user_prompt(content_text: str, keyword: str) -> str:
    trimmed_content = f"{content_text[:4000]}... (Ä°Ã§erik kÄ±saltÄ±ldÄ±)" if len(content_text) > 4000 else content_text
    return textwrap.dedent(
        f"""
        Analiz Edilecek Ä°Ã§erik:
        ---
        {trimmed_content}
        ---

        Hedef Anahtar Kelime: "{keyword}"

        Bu anahtar kelimeyle ilgili, kullanÄ±cÄ±larÄ±n sorabileceÄŸi ama metinde net 'Snippet' olarak bulunmayan 3-5 alt sorguyu (Fan-Out) bul.
        Her biri iÃ§in GEO kurallarÄ±na tam uyan Answer Block'lar oluÅŸtur. Her baÅŸlÄ±kta ana sorguyu tekrar et ve snippet'i tek cÃ¼mlede odaklÄ± tut.
        """
    ).strip()


def generate_geo_content(content_text: str, keyword: str) -> FanOutResult | None:
    """
    Ä°Ã§eriÄŸi analiz eder, fan-out sorgularÄ±nÄ± bulur ve validasyonlu bloklar Ã¼retir.

    Returns None if the model call fails.
    """

    system_prompt = _build_system_prompt()
    user_prompt = _build_user_prompt(content_text, keyword)

    try:
        completion = client.beta.chat.completions.parse(
            model="gpt-4o-2024-08-06",  # Structured Outputs destekleyen model
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt},
            ],
            response_format=FanOutResult,
        )

        return completion.choices[0].message.parsed

    except Exception as exc:  # noqa: BLE001 - bilinÃ§li olarak Ã¼st seviye yakalama
        print(f"Bir hata oluÅŸtu: {exc}")
        return None


# --- 3. Test Ã‡alÄ±ÅŸtÄ±rmasÄ± ---

if __name__ == "__main__":
    # Ã–rnek bir blog iÃ§eriÄŸi (SimÃ¼lasyon)
    sample_blog = """
    Form oluÅŸturucular, iÅŸletmelerin veri toplamasÄ±nÄ± saÄŸlar. Piyasada birÃ§ok seÃ§enek var.
    Jotform bunlardan biridir ve kullanÄ±mÄ± kolaydÄ±r. SÃ¼rÃ¼kle bÄ±rak Ã¶zelliÄŸi vardÄ±r.
    FiyatlandÄ±rma konusunda farklÄ± seÃ§enekler sunar. GÃ¼venlik Ã¶nlemleri de iyidir.
    Entegrasyonlar sayesinde verileri baÅŸka yerlere gÃ¶nderebilirsiniz.
    """

    keyword = "Online Form Builder"

    print(f"ğŸ¤– '{keyword}' iÃ§in GEO Analizi BaÅŸlatÄ±lÄ±yor...\n")
    result = generate_geo_content(sample_blog, keyword)

    if result:
        print(f"ğŸ“Š Strateji Ã–zeti: {result.analysis_summary}\n")
        for i, block in enumerate(result.blocks, 1):
            print(f"--- Answer Block #{i} ---")
            print(f"ğŸ¯ Niyet: {block.intent_category}")
            print(f"ğŸ” Sorgu: {block.target_query}")
            print(f"ğŸ·ï¸ BaÅŸlÄ±k: {block.heading}")
            print(f"ğŸ“ Ä°Ã§erik: {block.content}")
            print(f"â­ LMP PuanÄ±: {block.relevance_score}/100")
            print("-" * 30)
    else:
        print("Model yanÄ±t Ã¼retirken bir hata oluÅŸtu.")
